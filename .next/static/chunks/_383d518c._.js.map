{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/ai/flows/find-match-flow.ts"],"sourcesContent":["\n'use server';\n/**\n * @fileOverview A Genkit flow for matching users for a random chat.\n *\n * This flow provides a robust, transaction-based matchmaking system.\n * - findMatch: Tries to find a waiting user. If none, adds the user to the pool and waits.\n *              If no match is found within a timeout, it creates a bot match.\n */\n\nimport { z } from 'zod';\nimport { getFirestore, Timestamp } from 'firebase-admin/firestore';\nimport { initializeApp, getApps } from 'firebase-admin/app';\nimport { botNames, botOpenerMessages } from '@/config/bot-config';\n\nconst FindMatchInputSchema = z.object({\n  userId: z.string().describe('The UID of the user searching for a match.'),\n});\nexport type FindMatchInput = z.infer<typeof FindMatchInputSchema>;\n\nconst FindMatchOutputSchema = z.object({\n  conversationId: z.string().nullable().describe('The ID of the conversation, or null if no match was found yet.'),\n  isBotMatch: z.boolean().describe('Whether the match is with a bot.'),\n});\nexport type FindMatchOutput = z.infer<typeof FindMatchOutputSchema>;\n\nif (!getApps().length) {\n    initializeApp();\n}\nconst db = getFirestore();\nconst MATCH_TIMEOUT = 15000; // 15 seconds\n\nasync function createBotMatch(userId: string): Promise<FindMatchOutput> {\n    const userDocRef = db.doc(`users/${userId}`);\n    const userDocSnap = await userDocRef.get();\n    if (!userDocSnap.exists) throw new Error(\"Current user not found in database for bot match.\");\n\n    const currentUserData = userDocSnap.data()!;\n    const botId = `bot_${Math.random().toString(36).substring(2, 9)}`;\n    const botName = botNames[Math.floor(Math.random() * botNames.length)];\n    const botAvatar = `https://avatar.iran.liara.run/public/girl?username=${botName.replace(/\\s/g, '')}`;\n    \n    const botConvoId = [userId, botId].sort().join('-');\n    const botConvoRef = db.collection('temporaryConversations').doc(botConvoId);\n    \n    const expiresAt = new Date();\n    expiresAt.setMinutes(expiresAt.getMinutes() + 3);\n\n    await botConvoRef.set({\n        user1: { uid: currentUserData.uid, name: currentUserData.name, avatarUrl: currentUserData.avatarUrl, heartClicked: false },\n        user2: { uid: botId, name: botName, avatarUrl: botAvatar, heartClicked: false },\n        isBotMatch: true,\n        createdAt: Timestamp.now(),\n        expiresAt: Timestamp.fromDate(expiresAt),\n    });\n    \n    // Add bot's opener message\n    await botConvoRef.collection('messages').add({\n        text: botOpenerMessages[Math.floor(Math.random() * botOpenerMessages.length)],\n        senderId: botId,\n        timestamp: Timestamp.now()\n    });\n\n    return { conversationId: botConvoId, isBotMatch: true };\n}\n\n\nexport async function findMatch(input: FindMatchInput): Promise<FindMatchOutput> {\n    const { userId } = input;\n    const waitingPoolCollection = db.collection('waitingPool');\n\n    try {\n        // Transaction 1: Try to find a match immediately.\n        const immediateMatchResult = await db.runTransaction(async (transaction) => {\n            const waitingQuery = waitingPoolCollection\n                .where('uid', '!=', userId)\n                .orderBy('uid')\n                .orderBy('waitingSince', 'asc')\n                .limit(1);\n            \n            const waitingSnapshot = await transaction.get(waitingQuery);\n\n            if (waitingSnapshot.empty) {\n                // No one is waiting. Add current user to pool.\n                const userDoc = await transaction.get(db.doc(`users/${userId}`));\n                if (!userDoc.exists) throw new Error(\"User document does not exist.\");\n                \n                transaction.set(waitingPoolCollection.doc(userId), {\n                    uid: userId,\n                    name: userDoc.data()!.name,\n                    avatarUrl: userDoc.data()!.avatarUrl,\n                    waitingSince: Timestamp.now(),\n                });\n                return null; // Return null to indicate user is now waiting\n            }\n            \n            // Found a waiting user. Create a real match.\n            const waitingUserDoc = waitingSnapshot.docs[0];\n            const waitingUserData = waitingUserDoc.data();\n            const currentUserDoc = await transaction.get(db.doc(`users/${userId}`));\n            if (!currentUserDoc.exists) throw new Error(\"Current user not found.\");\n            const currentUserData = currentUserDoc.data()!;\n\n            const newConvoRef = db.collection('temporaryConversations').doc();\n            const expiresAt = new Date();\n            expiresAt.setMinutes(expiresAt.getMinutes() + 3);\n\n            transaction.set(newConvoRef, {\n                user1: { uid: waitingUserData.uid, name: waitingUserData.name, avatarUrl: waitingUserData.avatarUrl, heartClicked: false },\n                user2: { uid: currentUserData.uid, name: currentUserData.name, avatarUrl: currentUserData.avatarUrl, heartClicked: false },\n                isBotMatch: false,\n                createdAt: Timestamp.now(),\n                expiresAt: Timestamp.fromDate(expiresAt),\n            });\n            \n            // Remove the matched user from the pool\n            transaction.delete(waitingUserDoc.ref);\n\n            return { conversationId: newConvoRef.id, isBotMatch: false };\n        });\n\n        if (immediateMatchResult) {\n            return immediateMatchResult;\n        }\n\n        // If no immediate match, wait for the timeout.\n        await new Promise(resolve => setTimeout(resolve, MATCH_TIMEOUT));\n\n        // Transaction 2: After timeout, check if we were matched. If not, create a bot match.\n        const userInPoolRef = waitingPoolCollection.doc(userId);\n        const userInPoolSnap = await userInPoolRef.get();\n\n        if (!userInPoolSnap.exists()) {\n            // We were matched by someone else during the wait. We need to find that conversation.\n            const q = db.collection('temporaryConversations')\n                .where('users', 'array-contains', userId)\n                .orderBy('createdAt', 'desc')\n                .limit(1);\n\n            const convoSnapshot = await q.get();\n            if (!convoSnapshot.empty) {\n                return { conversationId: convoSnapshot.docs[0].id, isBotMatch: false };\n            } else {\n                // This is an edge case, something went wrong. Create a bot match as a fallback.\n                 await userInPoolRef.delete().catch(() => {});\n                 return createBotMatch(userId);\n            }\n        }\n        \n        // Still in the pool, nobody matched us. Create a bot match.\n        await userInPoolRef.delete();\n        return createBotMatch(userId);\n\n    } catch (error: any) {\n        console.error('Matchmaking flow failed:', error);\n        // Clean up user from pool just in case.\n        await waitingPoolCollection.doc(userId).delete().catch(() => {});\n        // As a last resort, give them a bot match instead of an error.\n        return createBotMatch(userId);\n    }\n}\n"],"names":[],"mappings":";;;;;;IAmEsB,YAAA,WAAA,GAAA,CAAA,GAAA,yNAAA,CAAA,wBAAA,EAAA,8CAAA,yNAAA,CAAA,aAAA,EAAA,KAAA,GAAA,yNAAA,CAAA,mBAAA,EAAA","debugId":null}},
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["file:///home/user/studio/src/app/%28app%29/shuffle/page.tsx"],"sourcesContent":["\n'use client';\n\nimport React, { useState, useEffect, Suspense, useRef } from 'react';\nimport { useRouter } from 'next/navigation';\nimport { Button } from '@/components/ui/button';\nimport { Loader2, Zap, MessageSquare } from 'lucide-react';\nimport { useToast } from '@/hooks/use-toast';\nimport { findMatch } from '@/ai/flows/find-match-flow';\nimport { auth } from '@/lib/firebase';\nimport { motion } from 'framer-motion';\n\nfunction ShuffleContent() {\n    const [isSearching, setIsSearching] = useState(false);\n    const router = useRouter();\n    const currentUser = auth.currentUser;\n    const { toast } = useToast();\n\n    const handleSearchClick = async () => {\n        if (!currentUser) {\n            toast({ title: \"Giriş yapmalısınız.\", variant: \"destructive\" });\n            return;\n        }\n\n        setIsSearching(true);\n\n        try {\n            const result = await findMatch({ userId: currentUser.uid });\n            \n            if (result && result.conversationId) {\n                toast({\n                    title: result.isBotMatch ? \"Sana birini bulduk!\" : \"Harika biriyle eşleştin!\",\n                    description: \"Sohbete yönlendiriliyorsun...\",\n                });\n                router.push(`/random-chat/${result.conversationId}`);\n            } else {\n                throw new Error(\"Eşleşme akışından bir sohbet ID'si dönmedi.\");\n            }\n\n        } catch (error: any) {\n            console.error(\"Error during match search: \", error);\n            toast({ title: \"Eşleşme ararken bir hata oluştu.\", description: error.message, variant: \"destructive\" });\n            setIsSearching(false);\n        }\n    };\n\n    if (isSearching) {\n        return (\n            <div className=\"flex flex-col items-center justify-center text-center p-8 w-full max-w-md\">\n                <Loader2 className=\"w-16 h-16 text-primary animate-spin\" />\n                <h2 className=\"text-2xl font-bold mt-6\">Sana Uygun Biri Aranıyor...</h2>\n                <p className=\"text-muted-foreground mt-2\">Bu işlem genellikle 15 saniye sürer. Lütfen bekleyin.</p>\n                 <Button variant=\"outline\" className=\"mt-8\" onClick={() => setIsSearching(false) /* This is a simple cancel, but won't stop the backend process */}>\n                    İptal\n                </Button>\n            </div>\n        );\n    }\n\n    return (\n        <div className='w-full max-w-sm flex flex-col items-center'>\n            <motion.div\n                initial={{ opacity: 0, scale: 0.8 }}\n                animate={{ opacity: 1, scale: 1 }}\n                transition={{ duration: 0.5, ease: \"easeOut\" }}\n            >\n                <h1 className=\"text-3xl font-bold font-headline\">Rastgele Eşleşme</h1>\n                <p className=\"max-w-md mt-2 mb-8 text-muted-foreground mx-auto text-center\">\n                    Tek bir tıkla yeni biriyle tanış ve 3 dakikalık sürpriz bir sohbete başla.\n                </p>\n                <div className=\"bg-background/80 backdrop-blur-sm border-2 border-primary/10 shadow-xl rounded-2xl w-full p-6 flex flex-col items-center\">\n                    <MessageSquare className='w-12 h-12 text-primary mb-4'/>\n                    <h2 className=\"text-2xl font-bold mb-4\">Yazılı Eşleşme</h2>\n                    <Button \n                        size=\"lg\" \n                        className=\"h-14 w-full text-lg rounded-full shadow-lg bg-gradient-to-r from-primary to-blue-500 text-primary-foreground transition-transform hover:scale-105\"\n                        onClick={handleSearchClick}\n                    >\n                        <Zap className=\"mr-3 h-5 w-5\" />\n                        Eşleşme Bul\n                    </Button>\n                </div>\n            </motion.div>\n        </div>\n    );\n}\n\nexport default function ShufflePage() {\n    return (\n        <div className=\"flex flex-col items-center justify-center h-full p-4 text-center relative overflow-hidden\">\n             <div className=\"absolute inset-0 bg-grid-pattern opacity-[0.03] dark:opacity-[0.05]\"></div>\n            <Suspense fallback={<Loader2 className=\"w-12 h-12 text-primary animate-spin\" />}>\n                <ShuffleContent />\n            </Suspense>\n        </div>\n    );\n}\n"],"names":[],"mappings":";;;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;AATA;;;;;;;;;AAWA,SAAS;;IACL,MAAM,CAAC,aAAa,eAAe,GAAG,CAAA,GAAA,6JAAA,CAAA,WAAQ,AAAD,EAAE;IAC/C,MAAM,SAAS,CAAA,GAAA,qIAAA,CAAA,YAAS,AAAD;IACvB,MAAM,cAAc,yHAAA,CAAA,OAAI,CAAC,WAAW;IACpC,MAAM,EAAE,KAAK,EAAE,GAAG,CAAA,GAAA,+HAAA,CAAA,WAAQ,AAAD;IAEzB,MAAM,oBAAoB;QACtB,IAAI,CAAC,aAAa;YACd,MAAM;gBAAE,OAAO;gBAAuB,SAAS;YAAc;YAC7D;QACJ;QAEA,eAAe;QAEf,IAAI;YACA,MAAM,SAAS,MAAM,CAAA,GAAA,6JAAA,CAAA,YAAS,AAAD,EAAE;gBAAE,QAAQ,YAAY,GAAG;YAAC;YAEzD,IAAI,UAAU,OAAO,cAAc,EAAE;gBACjC,MAAM;oBACF,OAAO,OAAO,UAAU,GAAG,wBAAwB;oBACnD,aAAa;gBACjB;gBACA,OAAO,IAAI,CAAC,CAAC,aAAa,EAAE,OAAO,cAAc,EAAE;YACvD,OAAO;gBACH,MAAM,IAAI,MAAM;YACpB;QAEJ,EAAE,OAAO,OAAY;YACjB,QAAQ,KAAK,CAAC,+BAA+B;YAC7C,MAAM;gBAAE,OAAO;gBAAoC,aAAa,MAAM,OAAO;gBAAE,SAAS;YAAc;YACtG,eAAe;QACnB;IACJ;IAEA,IAAI,aAAa;QACb,qBACI,6LAAC;YAAI,WAAU;;8BACX,6LAAC,oNAAA,CAAA,UAAO;oBAAC,WAAU;;;;;;8BACnB,6LAAC;oBAAG,WAAU;8BAA0B;;;;;;8BACxC,6LAAC;oBAAE,WAAU;8BAA6B;;;;;;8BACzC,6LAAC,qIAAA,CAAA,SAAM;oBAAC,SAAQ;oBAAU,WAAU;oBAAO,SAAS,IAAM,eAAe;8BAA0E;;;;;;;;;;;;IAKhK;IAEA,qBACI,6LAAC;QAAI,WAAU;kBACX,cAAA,6LAAC,6LAAA,CAAA,SAAM,CAAC,GAAG;YACP,SAAS;gBAAE,SAAS;gBAAG,OAAO;YAAI;YAClC,SAAS;gBAAE,SAAS;gBAAG,OAAO;YAAE;YAChC,YAAY;gBAAE,UAAU;gBAAK,MAAM;YAAU;;8BAE7C,6LAAC;oBAAG,WAAU;8BAAmC;;;;;;8BACjD,6LAAC;oBAAE,WAAU;8BAA+D;;;;;;8BAG5E,6LAAC;oBAAI,WAAU;;sCACX,6LAAC,2NAAA,CAAA,gBAAa;4BAAC,WAAU;;;;;;sCACzB,6LAAC;4BAAG,WAAU;sCAA0B;;;;;;sCACxC,6LAAC,qIAAA,CAAA,SAAM;4BACH,MAAK;4BACL,WAAU;4BACV,SAAS;;8CAET,6LAAC,mMAAA,CAAA,MAAG;oCAAC,WAAU;;;;;;gCAAiB;;;;;;;;;;;;;;;;;;;;;;;;AAOxD;GAzES;;QAEU,qIAAA,CAAA,YAAS;QAEN,+HAAA,CAAA,WAAQ;;;KAJrB;AA2EM,SAAS;IACpB,qBACI,6LAAC;QAAI,WAAU;;0BACV,6LAAC;gBAAI,WAAU;;;;;;0BAChB,6LAAC,6JAAA,CAAA,WAAQ;gBAAC,wBAAU,6LAAC,oNAAA,CAAA,UAAO;oBAAC,WAAU;;;;;;0BACnC,cAAA,6LAAC;;;;;;;;;;;;;;;;AAIjB;MATwB","debugId":null}},
    {"offset": {"line": 273, "column": 0}, "map": {"version":3,"file":"zap.js","sources":["file:///home/user/studio/node_modules/lucide-react/src/icons/zap.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  [\n    'path',\n    {\n      d: 'M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z',\n      key: '1xq2db',\n    },\n  ],\n];\n\n/**\n * @component @name Zap\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNNCAxNGExIDEgMCAwIDEtLjc4LTEuNjNsOS45LTEwLjJhLjUuNSAwIDAgMSAuODYuNDZsLTEuOTIgNi4wMkExIDEgMCAwIDAgMTMgMTBoN2ExIDEgMCAwIDEgLjc4IDEuNjNsLTkuOSAxMC4yYS41LjUgMCAwIDEtLjg2LS40NmwxLjkyLTYuMDJBMSAxIDAgMCAwIDExIDE0eiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/zap\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Zap = createLucideIcon('Zap', __iconNode);\n\nexport default Zap;\n"],"names":[],"mappings":";;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAuB,CAAA,CAAA,CAAA,CAAA;IAClC,CAAA;QACE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACA,CAAA;YACE,CAAG,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YACH,CAAA,CAAA,CAAK,EAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;QACP,CAAA;KACF;CACF,CAAA;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,GAAA,CAAM,CAAA,2KAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,AAAiB,CAAjB,CAAA,AAAiB,CAAjB,AAAiB,CAAjB,AAAiB,CAAA,CAAA,CAAA,EAAO,CAAU,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 312, "column": 0}, "map": {"version":3,"file":"message-square.js","sources":["file:///home/user/studio/node_modules/lucide-react/src/icons/message-square.ts"],"sourcesContent":["import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z', key: '1lielz' }],\n];\n\n/**\n * @component @name MessageSquare\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjEgMTVhMiAyIDAgMCAxLTIgMkg3bC00IDRWNWEyIDIgMCAwIDEgMi0yaDE0YTIgMiAwIDAgMSAyIDJ6IiAvPgo8L3N2Zz4K) - https://lucide.dev/icons/message-square\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst MessageSquare = createLucideIcon('MessageSquare', __iconNode);\n\nexport default MessageSquare;\n"],"names":[],"mappings":";;;;;;;;;;;AAGO,CAAA,CAAA,CAAA,CAAA,CAAA,CAAM,UAAuB,CAAA,CAAA,CAAA,CAAA;IAClC;QAAC,CAAA,CAAA,CAAA,CAAA,CAAA,CAAQ,CAAA;QAAA,CAAA;YAAE,GAAG,CAAiE,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA;YAAA,CAAA,CAAA,CAAA,CAAA,CAAK;QAAA,CAAU;KAAA;CAChG,CAAA;AAaM,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,aAAA,CAAgB,CAAA,2KAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,AAAiB,CAAjB,CAAA,AAAiB,CAAjB,AAAiB,CAAjB,AAAiB,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,EAAiB,CAAU,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA,CAAA","ignoreList":[0],"debugId":null}}]
}